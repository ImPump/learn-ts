# TypeScript 学习项目命名冲突解决方案

## 问题描述
在学习 TypeScript 过程中，多个文件可能包含相同的函数名（如 `add`、`greet` 等），这会导致命名冲突和编译错误。

## 解决方案

### 1. 使用命名空间（推荐）

为每个学习模块创建独立的命名空间：

```typescript
// 9.类型推论和类型别名.ts
namespace TypeInferenceAndAlias {
  function add(a: number, b: number) {
    return a + b
  }
  
  function greet(name: string) {
    return `Hello, ${name}!`
  }
}

// 3.函数扩展.ts
namespace FunctionExtensions {
  function add(a: number, b: number) {
    return a + b
  }
  
  function greet(name: string) {
    return `Hello, ${name}!`
  }
}
```

### 2. 使用模块导出

将每个文件作为独立模块：

```typescript
// 9.类型推论和类型别名.ts
export function add(a: number, b: number) {
  return a + b
}

export function greet(name: string) {
  return `Hello, ${name}!`
}

// 使用时需要导入
import { add, greet } from './9.类型推论和类型别名'
```

### 3. 使用前缀命名

为函数添加模块前缀：

```typescript
// 9.类型推论和类型别名.ts
function typeInferenceAdd(a: number, b: number) {
  return a + b
}

function typeInferenceGreet(name: string) {
  return `Hello, ${name}!`
}

// 3.函数扩展.ts
function functionExtAdd(a: number, b: number) {
  return a + b
}

function functionExtGreet(name: string) {
  return `Hello, ${name}!`
}
```

### 4. 使用立即执行函数表达式（IIFE）

```typescript
// 9.类型推论和类型别名.ts
(function() {
  function add(a: number, b: number) {
    return a + b
  }
  
  function greet(name: string) {
    return `Hello, ${name}!`
  }
  
  // 测试代码
  console.log(add(1, 2))
  console.log(greet('张三'))
})()
```

### 5. 使用 TypeScript 配置

创建 `tsconfig.json` 文件，设置模块解析：

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "node",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "isolatedModules": true
  },
  "include": [
    "**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}
```

## 命名空间 vs 模块导出详细对比

### 核心区别

| 特性 | 命名空间 | 模块导出 |
|------|----------|----------|
| **语法** | `namespace Name { }` | `export function/class/const` |
| **编译结果** | IIFE (立即执行函数) | ES6 模块 |
| **全局污染** | 部分避免 | 完全避免 |
| **树摇优化** | ❌ 不支持 | ✅ 支持 |
| **代码分割** | ❌ 不支持 | ✅ 支持 |
| **配置复杂度** | 低 | 中等 |
| **学习曲线** | 简单 | 中等 |

### 详细对比

#### 1. **语法和使用方式**

**命名空间：**
```typescript
namespace MathUtils {
  export function add(a: number, b: number) {
    return a + b
  }
}

// 直接使用
MathUtils.add(1, 2)
```

**模块导出：**
```typescript
export function add(a: number, b: number) {
  return a + b
}

// 需要导入后使用
import { add } from './math-utils'
add(1, 2)
```

#### 2. **编译结果**

**命名空间编译为：**
```javascript
var MathUtils;
(function (MathUtils) {
    function add(a, b) {
        return a + b;
    }
    MathUtils.add = add;
})(MathUtils || (MathUtils = {}));
```

**模块编译为：**
```javascript
export function add(a, b) {
    return a + b;
}
```

#### 3. **性能影响**

**命名空间：**
- ❌ 所有代码都会被打包，即使未使用
- ❌ 不支持代码分割
- ✅ 运行时性能较好

**模块导出：**
- ✅ 支持树摇优化，未使用的代码会被移除
- ✅ 支持代码分割和懒加载
- ✅ 更好的缓存策略

### 推荐方案

#### 对于学习项目：使用命名空间
- ✅ 简单易用，无需额外配置
- ✅ 代码组织清晰，避免全局污染
- ✅ 学习成本低，快速上手
- ✅ 适合单个文件的学习场景

#### 对于实际项目：使用模块导出
- ✅ 符合现代 JavaScript/TypeScript 标准
- ✅ 支持树摇优化，减少打包体积
- ✅ 更好的代码分割和懒加载
- ✅ 便于测试和维护
- ✅ 支持完整的模块系统特性

## 实施步骤

1. **选择方案**：根据项目需求选择合适的解决方案
2. **统一修改**：对所有文件应用相同的方案
3. **测试验证**：确保所有代码正常运行
4. **文档更新**：更新相关文档说明

## 注意事项

- 保持命名一致性
- 避免过度复杂的命名
- 考虑代码的可读性和维护性
- 在团队项目中统一命名规范

## 示例：批量修改脚本

如果需要批量修改所有文件，可以使用以下 PowerShell 脚本：

```powershell
# 为所有 TypeScript 文件添加命名空间
Get-ChildItem -Path "*.ts" -Recurse | ForEach-Object {
    $content = Get-Content $_.FullName -Raw
    $namespaceName = $_.BaseName -replace '[^a-zA-Z0-9]', ''
    
    if ($content -notmatch 'namespace\s+\w+\s*{') {
        $newContent = "namespace $namespaceName {`n" + $content + "`n}"
        Set-Content $_.FullName $newContent
    }
}
```

这样就能有效解决 TypeScript 学习过程中的命名冲突问题！ 